#!/usr/bin/env python3
import itertools
import logging
import threading
import time
import json
import os
from http.server import BaseHTTPRequestHandler
from socketserver import ThreadingTCPServer
from pathlib import Path

from mitmproxy import http

# ======================
# CONFIG
# ======================

GUI_HOST = "127.0.0.1"
GUI_PORT = 5001
MAX_BODY_PREVIEW = 50000

BASE_DIR = Path(__file__).resolve().parent
UI_DIR = BASE_DIR / "ui"

LOG_DIR = BASE_DIR / "proxy_logs"
LOG_DIR.mkdir(exist_ok=True)

# ======================
# LOGGING
# ======================

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
)
log = logging.getLogger("pentest-proxy")

# ======================
# SHARED STATE
# ======================

PENDING = {}    # rid -> info dict (for GUI pending view)
DECISIONS = {}  # rid -> decision dict
HISTORY = []    # list of info dicts with action/status/timestamp
STATE_LOCK = threading.Lock()
INTERCEPT_ON = True


def preview_body(raw: bytes) -> str:
    if not raw:
        return ""
    return raw[:MAX_BODY_PREVIEW].decode("utf-8", errors="replace")


def strip_security_headers(resp) -> None:
    """Remove common security headers from the response."""
    to_strip = [
        "Content-Security-Policy",
        "X-Frame-Options",
        "X-XSS-Protection",
        "Referrer-Policy",
        "Strict-Transport-Security",
        "Permissions-Policy",
    ]
    for h in to_strip:
        if h in resp.headers:
            del resp.headers[h]


def add_history_entry(info: dict, action: str, status_code=None):
    """
    Add a request to history list.
    info: dict with id/method/scheme/host/path/headers/body/client
    """
    entry = dict(info)
    entry["action"] = action
    entry["status_code"] = status_code
    entry["timestamp"] = time.time()
    with STATE_LOCK:
        HISTORY.append(entry)
        # Cap history size
        if len(HISTORY) > 1000:
            HISTORY.pop(0)


def update_history_status(rid, status_code):
    with STATE_LOCK:
        for entry in reversed(HISTORY):
            if entry.get("id") == rid:
                entry["status_code"] = status_code
                break


# ======================
# STATIC + API HTTP SERVER
# ======================

class ControlHandler(BaseHTTPRequestHandler):
    def _send_bytes(self, data: bytes, content_type: str, status: int = 200):
        self.send_response(status)
        self.send_header("Content-Type", content_type)
        self.send_header("Content-Length", str(len(data)))
        self.end_headers()
        self.wfile.write(data)

    def _send_json(self, obj, status=200):
        data = json.dumps(obj).encode("utf-8")
        self._send_bytes(data, "application/json", status)

    def _serve_static(self, rel_path: str):
        """
        Serve files from ./ui directory.
        rel_path is assumed to be without leading '/'.
        """
        if not rel_path or rel_path == "":
            rel_path = "index.html"

        # basic path sanitization
        rel_path = rel_path.lstrip("/")
        if ".." in rel_path:
            self._send_json({"error": "invalid path"}, status=400)
            return

        file_path = UI_DIR / rel_path
        if not file_path.is_file():
            self._send_json({"error": "not found"}, status=404)
            return

        # guess content type
        suffix = file_path.suffix.lower()
        if suffix == ".html":
            ctype = "text/html; charset=utf-8"
        elif suffix == ".css":
            ctype = "text/css; charset=utf-8"
        elif suffix == ".js":
            ctype = "application/javascript; charset=utf-8"
        else:
            ctype = "application/octet-stream"

        with open(file_path, "rb") as f:
            data = f.read()
        self._send_bytes(data, ctype)

    # --------- HTTP METHODS ---------

    def do_GET(self):
        # API endpoints first
        if self.path.startswith("/api/"):
            return self._handle_api_get()

        # static files
        if self.path == "/" or self.path == "/index.html":
            return self._serve_static("index.html")

        rel = self.path.lstrip("/")
        return self._serve_static(rel)

    def _handle_api_get(self):
        global INTERCEPT_ON

        if self.path == "/api/flows":
            with STATE_LOCK:
                flows = [
                    {
                        "id": rid,
                        "method": info["method"],
                        "url": f"{info['scheme']}://{info['host']}{info['path']}",
                    }
                    for rid, info in PENDING.items()
                ]
                log.info("GET /api/flows -> %d pending flows", len(PENDING))
            return self._send_json(flows)

        if self.path.startswith("/api/flows/"):
            parts = self.path.split("/")
            # /api/flows/<id>
            if len(parts) == 4 and parts[3]:
                try:
                    rid = int(parts[3])
                except ValueError:
                    return self._send_json({"error": "invalid id"}, status=400)
                with STATE_LOCK:
                    info = PENDING.get(rid)
                if not info:
                    return self._send_json({"error": "not found"}, status=404)
                return self._send_json(info)

        if self.path == "/api/history":
            with STATE_LOCK:
                # send a shallow copy to avoid race issues
                hist = list(HISTORY)
            return self._send_json(hist)

        if self.path == "/api/settings":
            with STATE_LOCK:
                intercept = INTERCEPT_ON
            return self._send_json({"intercept": intercept})

        return self._send_json({"error": "not found"}, status=404)

    def do_POST(self):
        global INTERCEPT_ON

        if self.path.startswith("/api/flows/") and self.path.endswith("/decision"):
            parts = self.path.split("/")
            # /api/flows/<id>/decision
            if len(parts) == 5 and parts[3]:
                try:
                    rid = int(parts[3])
                except ValueError:
                    return self._send_json({"error": "invalid id"}, status=400)

                length = int(self.headers.get("Content-Length", "0"))
                raw = self.rfile.read(length) if length > 0 else b"{}"
                try:
                    payload = json.loads(raw.decode("utf-8"))
                except Exception:
                    return self._send_json({"error": "bad json"}, status=400)

                with STATE_LOCK:
                    DECISIONS[rid] = payload
                return self._send_json({"status": "ok"})

        if self.path == "/api/settings":
            length = int(self.headers.get("Content-Length", "0"))
            raw = self.rfile.read(length) if length > 0 else b"{}"
            try:
                payload = json.loads(raw.decode("utf-8"))
            except Exception:
                return self._send_json({"error": "bad json"}, status=400)

            intercept = bool(payload.get("intercept", True))
            with STATE_LOCK:
                INTERCEPT_ON = intercept
            log.info("Intercept mode set to: %s", "ON" if intercept else "OFF")
            return self._send_json({"intercept": INTERCEPT_ON})

        return self._send_json({"error": "not found"}, status=404)

    # Silence default access logs
    def log_message(self, fmt, *args):
        return


def start_control_server():
    def _run():
        with ThreadingTCPServer((GUI_HOST, GUI_PORT), ControlHandler) as httpd:
            log.info("Web GUI listening on http://%s:%d", GUI_HOST, GUI_PORT)
            httpd.serve_forever()

    t = threading.Thread(target=_run, daemon=True)
    t.start()


# ======================
# MITMPROXY ADDON
# ======================

class PentestProxy:
    def __init__(self):
        self._id_counter = itertools.count(1)
        start_control_server()

    def request(self, flow: http.HTTPFlow) -> None:
        global INTERCEPT_ON
        req = flow.request

        # BYPASS our own GUI traffic (avoid deadlock)
        try:
            req_port = req.port
        except Exception:
            req_port = None

        if req.host in {GUI_HOST, "localhost", "127.0.0.1"} and req_port == GUI_PORT:
            log.debug(
                "Bypassing GUI request: %s %s://%s:%s%s",
                req.method,
                req.scheme,
                req.host,
                req_port,
                req.path,
            )
            return

        rid = flow.metadata.get("rid")
        if rid is None:
            rid = next(self._id_counter)
            flow.metadata["rid"] = rid

        client_addr = flow.client_conn.address
        headers_text = "\n".join(f"{k}: {v}" for k, v in req.headers.items())
        body_text = preview_body(req.raw_content or b"")

        info = {
            "id": rid,
            "client": f"{client_addr}",
            "scheme": req.scheme,
            "host": req.host,
            "path": req.path,
            "method": req.method,
            "headers": headers_text,
            "body": body_text,
        }

        with STATE_LOCK:
            intercept = INTERCEPT_ON

        if not intercept:
            # Intercept OFF: just log to history and let it pass through
            log.info(
                "[#%s] Intercept OFF, letting request pass: %s://%s%s",
                rid,
                req.scheme,
                req.host,
                req.path,
            )
            add_history_entry(info, action="pass-through", status_code=None)
            return

        # Intercept ON: queue for GUI decision
        with STATE_LOCK:
            PENDING[rid] = info

        log.info(
            "Request #%s queued for GUI decision: %s://%s%s",
            rid,
            req.scheme,
            req.host,
            req.path,
        )

        # Wait for a decision from the GUI
        while True:
            with STATE_LOCK:
                decision = DECISIONS.pop(rid, None)
            if decision is not None:
                break
            time.sleep(0.1)

        # Remove from pending
        with STATE_LOCK:
            PENDING.pop(rid, None)

        action = (decision.get("action") or "").lower()
        if action == "block":
            log.info("[#%s] BLOCKED by GUI", rid)
            # History: blocked before contacting server
            add_history_entry(info, action="blocked", status_code=403)
            flow.response = http.Response.make(
                403,
                f"Request #{rid} BLOCKED by proxy GUI.",
                {"Content-Type": "text/plain"},
            )
            return

        # Apply modifications
        new_method = decision.get("method") or req.method
        new_scheme = decision.get("scheme") or req.scheme
        new_host = decision.get("host") or req.host
        new_path = decision.get("path") or req.path
        new_headers_raw = decision.get("headers") or ""
        new_body = decision.get("body")

        # Method
        if new_method != req.method:
            log.info("[#%s] Method: %s -> %s", rid, req.method, new_method)
            req.method = new_method

        # Scheme (usually http/https)
        if new_scheme and new_scheme != req.scheme:
            log.info("[#%s] Scheme: %s -> %s", rid, req.scheme, new_scheme)
            req.scheme = new_scheme

        # Host
        if new_host and new_host != req.host:
            log.info("[#%s] Host: %s -> %s", rid, req.host, new_host)
            req.host = new_host
            req.headers["Host"] = new_host

        # Path
        if new_path and new_path != req.path:
            if not new_path.startswith("/"):
                new_path = "/" + new_path
            log.info("[#%s] Path: %s -> %s", rid, req.path, new_path)
            req.path = new_path

        # Headers
        if new_headers_raw:
            log.info("[#%s] Headers replaced from GUI", rid)
            req.headers.clear()
            for line in new_headers_raw.splitlines():
                line = line.strip()
                if not line:
                    continue
                if ":" not in line:
                    continue
                name, value = line.split(":", 1)
                req.headers[name.strip()] = value.strip()

        # Body
        if new_body is not None:
            log.info("[#%s] Body replaced from GUI (%d chars)", rid, len(new_body))
            req.text = new_body  # mitmproxy adjusts content-length

        # Response macros
        if decision.get("strip_security_headers"):
            flow.metadata["strip_security_headers"] = True

        # History: allowed; status code will be updated in response()
        add_history_entry(info, action="allowed", status_code=None)

        log.info("[#%s] ALLOWED by GUI", rid)

    def response(self, flow: http.HTTPFlow) -> None:
        rid = flow.metadata.get("rid")
        resp = flow.response

        if flow.metadata.get("strip_security_headers"):
            strip_security_headers(resp)
            log.info("[#%s] Security headers stripped", rid if rid is not None else "?")

        if rid is not None:
            update_history_status(rid, resp.status_code)

        log.info(
            "Response #%s: %s %s",
            rid if rid is not None else "?",
            resp.status_code,
            resp.reason,
        )


# Only define addons when loaded by mitmdump as a script
if __name__ != "__main__":
    addons = [PentestProxy()]


if __name__ == "__main__":
    # Launcher: run mitmdump in a separate process using this file as the script.
    script_path = os.path.abspath(__file__)
    cmd = ["mitmdump", "-s", script_path, "-p", "8080"]
    os.execvp("mitmdump", cmd)
